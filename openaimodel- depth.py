# -*- coding: utf-8 -*-
"""openaimodel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zaJrxdFT2zHTso8gy-wrQUHFnMQwAHME
"""

import math
import numpy as np
import torch as th
import torch.nn as nn
from abc import abstractmethod
import torch.nn.functional as F

from util import (
    checkpoint, conv_nd, avg_pool_nd, zero_module, normalization,
    timestep_embedding
)
#Parentheses let you break the import into multiple lines without using \
#in Python, the backslash \ is a line continuation character
from attention import SpatialTransformer


def exists(x):
  return x is not None

def convert_module_to_f16(x):
  pass

def convert_module_to_f32(x):
  pass

class AttentionPool2d(nn.Module):
  def __init__(self, spacial_dim: int, embed_dim: int,
               num_heads_channels: int, output_dim: int = None,):
    #output_dim: int → Type hint saying "output_dim should be an integer", None by default
    super().__init__()
    self.positional_embedding = nn.Parameter(
        th.randn(embed_dim, spacial_dim ** 2 + 1) / embed_dim ** 0.5
    )
    self.qkv_proj = conv_nd(1, embed_dim, 3 * embed_dim, 1) #1 is the kernel size
    self.c_proj = conv_nd(1, embed_dim, output_dim or embed_dim, 1) #If output_dim is given (i.e., not None or 0 or False), use it.
                                                                    #Otherwise, default to embed_dim
    self.num_heads = embed_dim // num_heads_channels
    self.atention = QKVAttention(self.num_heads)

  def forward(self, x):
    b, c, *_spatial = x.shape
    x = x.reshape(b, c, -1) #shape: [B, C, H*W]
    x = th.cat([x.mean(dim=-1, keepdim=True), x], dim=-1) #shape: [B, C, 1 + H*W]
    x = x + self.positional_embedding[None, :, :].to(x.dtype)
    x = self.qkv_proj(x)
    x = self.attention(x)
    x = self.c_proj(x)
    return x[:, :, 0]
'''
-This module takes a 2d image feature map and converts it into a pooled global
representation using attention
-self.positional_embedding from nn.Parmeter is a learnable positional embedding
  Note: Only learnable parameters appear in model.parameters() and get updated by the optimizer
 The shape'es [C, H*W + 1] plus one is for the global token
-torch.cat prepends a global token, the mean of all spatial tokens
    x = torch.randn(2, 3, 4)  # shape = [2, 3, 4]
    mean = x.mean(dim=-1) #shape = [2, 3] because the last dim is reduced.
                           keepdim is used to preserve the shape, last dim is set to size 1
 This mean acts like a summary vector that will attend to all others and be returned
 as the pooled output.
-self.positional_embedding[None, :, :]
 This adds a batch dimension [C, 1 + H*W] --> [1, C, 1 + H*W]
 This makes it broadcastable acroos the batch
 Now, x = x + self.positional_embedding[None, :, :] adds the same positional
     encoding to every sample in the batch
-return x[:, :, 0]
 The global token that was prepended earlier becomes the pooled representation
 of the image after attention
'''

class TimestepBlock(nn.Module):
  #Any module where forward() takes timestep embeddings as a second argument.
  @abstractmethod
  def forward(self, x, emb):
    pass


class TimestepEmbedSequential(nn.Sequential, TimestepBlock):

  #A sequential module that passes timestep embeddings to the children that
  #support it as an extra input.

  def forward(self, x, emb, context=None):
    for layer in self:
      if isinstance(layer, TimestepBlock):
        x = layer(x, emb)
      elif isinstance(layer, SpatialTransformer):
        x = layer(x, context)
      else:
        x = layer(x)
    return x

class Upsample(nn.Module):

   """
    An upsampling layer with an optional convolution.
    :param channels: channels in the inputs and outputs.
    :param use_conv: a bool determining if a convolution is applied.
    :param dims: determines if the signal is 1D, 2D, or 3D. If 3D, then
                 upsampling occurs in the inner-two dimensions.
    """
   def __init__(self, channels, use_conv, dims=2, out_channels=None, padding=1):
    self.channels = channels
    self.out_channels = out_channels or channels
    self.use_conv = use_conv
    self.dims = dims
    if self.use_conv:
      self.conv = conv_nd(dims, self.channels, self.out_channels, 3, padding=padding)

   def forward(self, x):
    assert x.shape[1] == self.channels
    if self.dims == 3: #For 3d inputs
      x = F.interpolate(
          x, (x.shape[2], x.shape[3] * 2, x.shape[4] * 2), #only upsample height, width and not depth
          mode="nearest"
      )
    else:
      x = F.interpolate(x, scale_factor=2, mode="nearest")
    if self.use_conv:
      x = self.conv(x)
    return x

'''Nearest-neighbor interpolation means that when the input is upsampled,
   each new pixel (or voxel) is assigned the value of the nearest pixel from
   the original input — no averaging, no smoothing'''

class TransposedUpsample(nn.Module):
  #Learned 2x upsampling without padding
  def __init__(self, channels, out_channels=None, ks=5):
    super().__init__()
    self.channels = channels
    self.out_channels = out_channels or channels
    self.up = nn.ConvTranspose2d(self.channels,
                                 self.out_channels,
                                 kernel_size=ks, stride=2)

  def forward(self, x):
    return self.up(x)

class Downsample(nn.Module):
  def __init__(self, channels, use_conv, dims=2, out_channels=None, padding=1):
    super().__init__()
    self.channels = channels
    self.out_channels = out_channels or channels
    self.use_conv = use_conv
    self.dims = dims
    stride = 2 if dims != 3 else (1, 2, 2) # Only downsample height and width for 3D
    if use_conv:
      self.op = conv_nd(
          dims, self.channels, self.out_channels, 3, stride=stride, padding=1
      )
    else:
      assert self.channels == self.out_channels
      self.op = avg_pool_nd(dims, kernel_size=stride, stride=stride)
      #No need to tell AvgPool2d how many channels are present
      # — it just applies the same operation to all of them

  def forward(self, x):
    assert x.shape[1] == self.channels
    return self.op(x)

class ResBlock(TimestepBlock):
    """
    A residual block that can optionally change the number of channels.
    :param channels: the number of input channels.
    :param emb_channels: the number of timestep embedding channels.
    :param dropout: the rate of dropout.
    :param out_channels: if specified, the number of out channels.
    :param use_conv: if True and out_channels is specified, use a spatial
        convolution instead of a smaller 1x1 convolution to change the
        channels in the skip connection.
    :param dims: determines if the signal is 1D, 2D, or 3D.
    :param use_checkpoint: if True, use gradient checkpointing on this module.
    :param up: if True, use this block for upsampling.
    :param down: if True, use this block for downsampling.
    """
    def __init__(self, channels, emb_channels, dropout,
                 out_channels=None, use_conv=False,
                 use_scale_shift_norm=False, dims=2, use_checkpoint=False,
                 up=False, down=False):

      super().__init__()
      self.channels = channels
      self.emb_channels = emb_channels
      self.dropout = dropout
      self.out_channels = out_channels or channels
      self.use_conv = use_conv
      self.use_checkpoint = use_checkpoint
      self.use_scale_shift_norm = use_scale_shift_norm
      self.in_layers = nn.Sequential(
           normalization(channels,
                         nn.SiLU(),
                         conv_nd(dims, channels, self.out_channels, 3, padding=1))
                          #output has same spatial size as input
       )

      self.updown = up or down
      if up:
       self.h_upd = Upsample(channels, False, dims)
       self.x_upd = Upsample(channels, False, dims)
      elif down:
       self.h_upd = Downsample(channels, False, dims)
       self.x_upd = Downsample(channels, False, dims)
      else:
       self.h_upd = self.x_upd = nn.Identity()

      self.emb_layers = nn.Sequential(

          nn.SiLU(),
          linear(emb_channels,
                 2 * self.out_channels if use_scale_shift_norm else self.out_channels,),
      )

      self.out_layers = nn.Sequential(
          normalization(self.out_channels),
          nn.SiLU(),
          nn.Dropout(p=dropout),
          zero_module(
              conv_nd(dims, self.out_channels, self.out_channels, 3, padding=1)
          ),
      )

      if self.out_channels == channels:
        self.skip_connection = nn.Identity()
      elif use_conv:
        self.skip_connection = conv_nd(
            dims, channels, self.out_channels, 3, padding=1
        )
      else:
        self.skip_connection = conv_nd(
            dims, channels, self.out_channels, 1
        )

    def forward(self, x, emb):
      """
        Apply the block to a Tensor, conditioned on a timestep embedding.
        :param x: an [N x C x ...] Tensor of features.
        :param emb: an [N x emb_channels] Tensor of timestep embeddings.
        :return: an [N x C x ...] Tensor of outputs.
        """
      return checkpoint(
            self._forward, (x, emb), self.parameters(), self.use_checkpoint
        )

    def _forward(self, x, emb):
      if self.updown:
        in_rest, in_conv = self.in_layers[:-1], self.in_layers[-1]
        h = in_rest(x)
        h = self.h_upd(h)
        x = self.x_upd(x)
        h = in_conv(h)
      else:
        h = self.in_layers(x)

      emb_out = self.emb_layers(emb).type(h.dtype)
      while len(emb_out.shape) < len(h.shape):
        emb_out = emb_out[..., None]

      if self.use_scale_shift_norm:
        out_norm, out_rest = self.out_layers[0], self.out_layers[1:]
        scale, shift = th.chunk(emb_out, 2, dim=1)
        h = out_norm(h) * (1 + scale) + shift
        h = out_rest(h)
      else:
        h = h + emb_out
        h = self.out_layers(h)

      return self.skip_connection(x) + h

'''
This is a sophisticated ResNet module customized for conditioning on time step embeddings
self.in_layers --> First half of the residual block(output's spatial size)
                    remains the same
self.em_layers --> Projects the timestep embedding to a shape compatible
                    with h
self.out_layers --> Second half of the residual block
                    Applies a 3x3 conv wrapped in zero_module(initializes weight to zero)

-What is "conditionally modulated"?
It means the output of a network layer is modified based on an external
input, often called a condition. Here, the network acts differently
at early vs late time steps due to the time step embeddings

-What does self.h_upd = self.x_upd = nn.Identity() mean?
When up=False and down=False, there is no upsampling or downsampling,
 and the model just passes x and h through unchanged

-What are scale and shift?
They come from scale-and-shift normalization, often used in
conditional normalization
  --scale, shift = torch.chunk(emb_out, 2, dim=1)--
  emb_out is split in half where first half is the scale
                                 second half is the shift
They allow the network to modulate (tweak) its internal behavior
based on the timestep. It gives the network fine-grained control over data.

-Why initialize weights to zero in zero_module(...)? Isn’t that wasteful?
So that at epoch 0, the residual path contributes nothing: skip_connection(x) + 0 = x
This allows the model to:
  Start from a safe state (identity)
  Gradually learn meaningful transformations in the residual path
Also, zero_module() is called only once, during __init__ when the model is
being built to ensure that early training doesn’t destabilize from random attention output
From then on:
  self.out_layers is just a normal nn.Sequential
  The convolution inside has trainable weights
  Those weights are updated by backpropagation
  zero_module is never called again during forward or training

- x -->Original input used for skip connection
  h -->Transformed path
  '''

class AttentionBlock(nn.Module):
  #An attention block that allows spatial positions to attend to each other
  #Like a Transformer, but applied to feature maps
  def __init__(self, channels, num_heads=1, num_head_channels=-1,
               use_checkpoint=False, use_new_attention_order=False):
    super().__init__()
    self.channels = channels
    if num_head_channels == -1:
      self.num_heads = num_heads
    else:
      assert(
          channels % num_head_channels == 0
      ), f"q,k,v channels {channels} is not divisible by num_head_channels {num_head_channels}"
      self.num_heads = channels // num_head_channels

    self.use_checkpoint = use_checkpoint
    self.norm = normalization(channels)
    self.qkv = conv_nd(1, channels, channels * 3, 1)
    if use_new_attention_order:
      #split qkv before split heads
      self.attention = QKVAttention(self.num_heads)
    else:
      #split heads before split qkv
      self.attention = QKVAttentionLegacy(self.num_heads)

    self.proj_out = zero_module(conv_nd(1, channels, channels, 1))

  def forward(self, x):
    return checkpoint(
        self._forward, (x,), (self.parameters(), True))

  def _forward(self, x):
    b, c, *spatial = x.shape
    x = x.reshape(b, c, -1)
    qkv = self.qkv(self.norm(x))
    h = self.attention(qkv)
    h = self.proj_out(h)

    return (x + h).reshape(b, c, *spatial)

def count_flops_attn(model, _x, y):
  b, c, *spatial = y[0].shape
  num_spatial = int(np.prod(spatial))

  matmul_ops = 2 * b * (num_spatial ** 2) * c
  model.total_ops += th.DoubleTensor([matmul_ops])
#Each "FLOP" is one arithmetic operation
#Likely calculated for a profiling tool

class QKVAttentionLegacy(nn.Module):
  def __init__(self, n_heads):
    super().__init__()
    self.n_heads = n_heads

  def forward(self, qkv):
    bs, width, length = qkv.shape
    assert width % (3 * self.n_heads) == 0
    ch = width // (3 * self.n_heads)
    q, k, v = qkv.reshape(bs * self.n_heads, ch * 3, length).split(ch, dim=1)
    scale = 1 / math.sqrt(math.sqrt(ch))
    weight = th.einsum(
            "bct,bcs->bts", q * scale, k * scale
        )  # More stable with f16 than dividing afterwards
    weight = th.softmax(weight.float(), dim=-1).type(weight.dtype)
    a = th.einsum("bts,bcs->bct", weight, v)
    return a.reshape(bs, -1, length)

  @staticmethod
  def count_flops(model, _x, y):
    return count_flops_attn(model, _x, y)

'''
This is the  legacy version of a QKV attention module, as used in earlier
diffusion or Transformer-style models.

- Apply QKV attention.
   :param qkv: an [N x (H * 3 * C) x T] tensor of Qs, Ks, and Vs.
   :return: an [N x (H * C) x T] tensor after attention.
        T is the sequence length, but the authors chose to unpack it as b, w, l
        H is the number of heads, and C is the number of channels per head
-The qkv arrays are reshaped such that each head gets its own slice of
 Q, K, V
-weight calculates the attention weights between q, and k
-The weights are passed through softmax
-The context vectors are multiplied with thevalue vectors to get attention scores'''

class QKVAttention(nn.Module):
  def __init__(self, n_heads):
    super().__init__()
    self.n_heads = n_heads

  def forward(self, qkv):
    """
        Apply QKV attention.
        :param qkv: an [N x (3 * H * C) x T] tensor of Qs, Ks, and Vs.
        :return: an [N x (H * C) x T] tensor after attention.
    """
    bs, width, length = qkv.shape
    assert width % (3 * self.n_heads) == 0
    ch = width // (3 * self.n_heads)
    q, k, v = qkv.chunk(3, dim=1)
    scale = 1 / math.sqrt(math.sqrt(ch))
    weight = th.einsum(
        "bct,bcs->bts",
        (q * scale).view(bs * self.n_heads, ch, length),
        (k * scale).view(bs * self.n_heads, ch, length),
    )
    weight = th.softmax(weight.float(), dim=-1).type(weight.dtype)
    a = th.einsum(
        "bts,bcs->bct", weight, v.reshape(bs * self.n_heads, ch, length)
    )
    return a.reshape(bs, -1, length)
  @staticmethod
  def count_flops(model, _x, y):
    return count_flops_attn(model, _x, y)

'''
-(q * scale).view(bs * self.n_heads, ch, length)
 We want to compute attention per head, so we reshape
 [B, H*C, T] -> [B*H, C, T]
 -Why an @staticmethod if the class isn’t abstract?
  Abstractness is unrelated. A method is made @staticmethod when it
  doesn’t use self or cls (no instance/class state needed
'''

class Timestep(nn.Module):
  def __init__(self, dim):
    super().__init__()
    self.dim = dim

  def forward(self, t):
    return timestep_embedding(t, self.dim)

class UNetModel(nn.Module):
    """
    The full UNet model with attention and timestep embedding.
    :param in_channels: channels in the input Tensor.
    :param model_channels: base channel count for the model.
    :param out_channels: channels in the output Tensor.
    :param num_res_blocks: number of residual blocks per downsample.
    :param attention_resolutions: a collection of downsample rates at which
        attention will take place. May be a set, list, or tuple.
        For example, if this contains 4, then at 4x downsampling, attention
        will be used.
    :param dropout: the dropout probability.
    :param channel_mult: channel multiplier for each level of the UNet.
    :param conv_resample: if True, use learned convolutions for upsampling and
        downsampling.
    :param dims: determines if the signal is 1D, 2D, or 3D.
    :param num_classes: if specified (as an int), then this model will be
        class-conditional with `num_classes` classes.
    :param use_checkpoint: use gradient checkpointing to reduce memory usage.
    :param num_heads: the number of attention heads in each attention layer.
    :param num_heads_channels: if specified, ignore num_heads and instead use
                               a fixed channel width per attention head.
    :param num_heads_upsample: works with num_heads to set a different number
                               of heads for upsampling. Deprecated.
    :param use_scale_shift_norm: use a FiLM-like conditioning mechanism.
    :param resblock_updown: use residual blocks for up/downsampling.
    :param use_new_attention_order: use a different attention pattern for potentially
                                    increased efficiency.
    """

    def __init__(
        self,
        image_size,
        in_channels,
        model_channels,
        out_channels,
        num_res_blocks,
        attention_resolutions,
        dropout=0,
        channel_mult=(1, 2, 4, 8),
        conv_resample=True,
        dims=2,
        num_classes=None,
        use_checkpoint=False,
        use_fp16=False,
        use_bf16=False,
        num_heads=-1,
        num_head_channels=-1,
        num_heads_upsample=-1,
        use_scale_shift_norm=False,
        resblock_updown=False,
        use_new_attention_order=False,
        use_spatial_transformer=False,    # custom transformer support
        transformer_depth=1,              # custom transformer support
        context_dim=None,                 # custom transformer support
        n_embed=None,                     # custom support for prediction of discrete ids into codebook of first stage vq model
        legacy=True,
        disable_self_attentions=None,
        num_attention_blocks=None,
        disable_middle_self_attn=False,
        use_linear_in_transformer=False,
        adm_in_channels=None,
        load_from_ckpt=None,
    ):
        
        super().__init__()
        if use_spatial_transformer:
            assert context_dim is not None, 'Fool!! You forgot to include the dimension of your cross-attention conditioning...'

        if context_dim is not None:
            assert use_spatial_transformer, 'Fool!! You forgot to use the spatial transformer for your cross-attention conditioning...'
            #Because cross-attention conditioning requires a spatial transformer to integrate it into the feature map
            from omegaconf.listconfig import ListConfig
            #YAML = YAML Ain’t Markup Language
            #Sometimes, the parameter can be a ListConfig object from a YAML file
            if type(context_dim) == ListConfig:
                context_dim = list(context_dim)
        if num_heads_upsample == -1:
            num_heads_upsample = num_heads

        if num_heads == -1:
            assert num_head_channels != -1, 'Either num_heads or num_head_channels has to be set'

        if num_head_channels == -1:
            assert num_heads != -1, 'Either num_heads or num_head_channels has to be set'

        self.image_size = image_size
        self.in_channels = in_channels
        self.model_channels = model_channels
        self.out_channels = out_channels
        if isinstance(num_res_blocks, int):
            self.num_res_blocks = len(channel_mult) * [num_res_blocks]
        else:
            if len(num_res_blocks) != len(channel_mult):
                raise ValueError("provide num_res_blocks either as an int (globally constant) or "
                                 "as a list/tuple (per-level) with the same length as channel_mult")
            self.num_res_blocks = num_res_blocks
            #channel_mult is usually a list that says how the number of channels changes at each stage
            #e.g., channel_mult = [1, 2, 4, 8]
            #Stage1 --> base_channels * 1
            #Stage2 --> base_channels * 2..
            #If num_res_blocks is a single integer:
            #That means you want the same number of residual blocks at every stage.
            #len(channel_mult) * [num_res_blocks] creates a list repeating that number for each stage
            #e.g., num_resblocks = 2
            #channel_mult = [1, 2, 4]
            #self.num_resblocks = [2, 2, 2]
            #If num_res_blocks is not an integer (probably a list or tuple):
            #Then the list must match the number of stages in channel_mult.
            #Each entry tells how many residual blocks to use at that stage.
            #e.g., num_resblocks = [2, 3, 4]
            #channel_mult = [1, 2, 4] -->channel_mult tells us how channels grow at each stage
            #self.num_resblocks = [2, 3, 4]
        if disable_self_attentions is not None:
            ## should be a list of booleans, indicating whether to disable self-attention in TransformerBlocks or not
            assert len(disable_self_attentions) == len(channel_mult)

        if num_attention_blocks is not None:
            assert len(num_attention_blocks) == len(self.num_res_blocks)
            assert all(map(lambda i: self.num_res_blocks[i] >= num_attention_blocks[i], range(len(num_attention_blocks))))
            print(f"Constructor of UNetModel received num_attention_blocks={num_attention_blocks}. "
                  f"This option has LESS priority than attention_resolutions {attention_resolutions}, "
                  f"i.e., in cases where num_attention_blocks[i] > 0 but 2**i not in attention_resolutions, "
                  f"attention will still not be set.")
            #You can’t ask for more attention blocks than the total residual blocks available in that stage
            #attention_resolutions is a set of downsample factors (e.g., {4, 8, 16}) that say which stages are
            #even allowed to use attention. Conventionally, stage index i corresponds to spatial scale 2**i
            #(assuming you downsample by 2 per stage)
            #if a stage’s resolution (2**i) is not in attention_resolutions, then no attention is inserted in that stage
            '''
self.num_res_blocks = [2, 2, 3, 3] # 4 stages (i = 0..3)
attention_resolutions = {4, 16}
num_attention_blocks = [0, 1, 2, 3]
Stage 0 (scale 1): 0 attention requested → fine.
Stage 1 (scale 2): 1 requested, but 2 ∉ {4} → ignored, no attention.
Stage 2 (scale 4): 2 requested, 4 ∈ {4} → allowed, place 2 attention blocks within the 3 residual blocks.
Stage 3 (scale 8): 3 requested, 8 ∉ {4} → ignored, no attention
'''
        self.attention_resolutions = attention_resolutions
        self.dropout = dropout
        self.channel_mult = channel_mult
        self.conv_resample = conv_resample
        self.num_classes = num_classes
        self.use_checkpoint = use_checkpoint
        self.dtype = th.float16 if use_fp16 else th.float32
        self.dtype = th.bfloat16 if use_bf16 else self.dtype
        self.num_heads = num_heads
        self.num_head_channels = num_head_channels
        self.num_heads_upsample = num_heads_upsample
        self.predict_codebook_ids = n_embed is not None

        time_embed_dim = model_channels * 4
        self.time_embed = nn.Sequential(
            linear(model_channels, time_embed_dim),
            nn.SiLU(),
            linear(time_embed_dim, time_embed_dim),
        )

        if self.num_classes is not None:
            if isinstance(self.num_classes, int):
                self.label_emb = nn.Embedding(num_classes, time_embed_dim)
            elif self.num_classes == "continuous":
                print("setting up linear c_adm embedding layer")
                self.label_emb = nn.Linear(1, time_embed_dim)
            elif self.num_classes == "sequential":
                assert adm_in_channels is not None
                self.label_emb = nn.Sequential(
                    nn.Sequential(
                        linear(adm_in_channels, time_embed_dim),
                        nn.SiLU(),
                        linear(time_embed_dim, time_embed_dim),
                    )
                )
            else:
                raise ValueError()
        '''
-Why are we even talking about “classes” in a UNet?
A UNet (or any neural network) normally just takes an image (or noisy image) as input.
But sometimes you want to control the output by telling the model what to generate.
Example:
“Draw a picture of a dog.”
“Generate a flower with 5 petals.”
“Restore this noisy MRI image from patient aged 65.”
That “extra information” is called conditioning.
Conditioning can come in many forms:
  Class ID — a number representing a category (e.g., 0=cat, 1=dog).
  Scalar value — a single real number (e.g., age = 65.0, blur strength = 0.73).
  Feature vector — many numbers(already a vector), each describing something (e.g., a 512-dimensional text embedding from CLIP).

-How do we feed this conditioning into the network?
Neural networks don’t understand plain integers or raw numbers as labels —
we have to turn them into vectors that the network can work with

-Where does this go?
No matter which branch is used, the result is:
  A vector of size time_embed_dim
  This vector is added to the timestep embedding inside the UNet’s ResBlocks
That way, the UNet “knows” both:
  What timestep it’s at in the diffusion process
  What extra condition it should follow
'''

        self.input_blocks = nn.ModuleList(
        [
            TimestepEmbedSequential(
                conv_nd(dims, in_channels, model_channels, 3, padding=1)
            )
        ]
    )
        self._feature_size = model_channels
        input_block_chans = [model_channels]
        ch = model_channels
        ds = 1
        for level, mult in enumerate(channel_mult):   
            for nr in range(self.num_res_blocks[level]):
                layers = [
                    ResBlock(
                        ch,
                        time_embed_dim,
                        dropout,
                        out_channels=mult * model_channels,
                        dims=dims,
                        use_checkpoint=use_checkpoint,
                        use_scale_shift_norm=use_scale_shift_norm,
                    )
                ]
                ch = mult * model_channels
                if ds in attention_resolutions:
                    if num_head_channels == -1:
                        dim_head = ch // num_heads
                    else:
                        num_heads = ch // num_head_channels
                        dim_head = num_head_channels
                    if legacy:
                        dim_head = ch // num_heads if use_spatial_transformer else num_head_channels
                    if exists(disable_self_attentions):
                        disabled_sa = disable_self_attentions[level]
                    else:
                        disabled_sa = False

                    if not exists(num_attention_blocks) or nr < num_attention_blocks[level]:
                        layers.append(
                            AttentionBlock(
                                ch,
                                use_checkpoint=use_checkpoint,
                                num_heads=num_heads,
                                num_head_channels=dim_head,
                                use_new_attention_order=use_new_attention_order,
                            ) if not use_spatial_transformer else SpatialTransformer(
                                ch, num_heads, dim_head, depth=transformer_depth, context_dim=context_dim,
                                disable_self_attn=disabled_sa, use_linear=use_linear_in_transformer,
                                use_checkpoint=use_checkpoint
                            )
                        )
                self.input_blocks.append(TimestepEmbedSequential(*layers))
                self.feature_size += ch
                input_block_chans.append(ch)
            
            '''
The model builds a list of input blocks. Each “stage” (a downsampling level) has:
Several ResBlocks (residual conv blocks, timestep‑conditioned)
Optional attention after some ResBlocks (either classic AttentionBlock or a SpatialTransformer for cross‑attention)
Channel count grows by mult * model_channels as you go deeper.
ds tracks the current downsample factor (1, 2, 4, 8, …). Attention is only enabled at certain resolutions.


'''

            if level != len(channel_mult) - 1:
                out_ch = ch
                self.input_blocks.append(
                    TimestepEmbedSequential(
                        ResBlock(
                            ch,
                            time_embed_dim,
                            dropout,
                            out_channels=out_ch,
                            dims=dims,
                            use_checkpoint=use_checkpoint,
                            use_scale_shift_norm=use_scale_shift_norm,
                            down=True,
                        )
                        if resblock_updown
                        else Downsample(
                            ch, conv_resample, dims=dims, out_channels=out_ch
                        )
                    )
                )
                ch = out_ch
                input_block_chans.append(ch)
                #input_block_chans is basically a list that records how many channels each block in self.input_blocks outputs
                ds *= 2
                self.feature_size += ch
        if num_head_channels == -1:
            dim_head = ch // num_heads
        else:
            num_heads = ch // num_head_channels
            dim_head = num_head_channels
        if legacy:
            dim_head = ch // num_heads if use_spatial_transformer else num_head_channels
      #dim_head = ch//num_heads (or) num_head_channels
        self.middle_block = TimestepEmbedSequential(
          ResBlock(
            ch,
            time_embed_dim,
            dropout,
            dims=dims,
            use_checkpoint=use_checkpoint,
            use_scale_shift_norm=use_scale_shift_norm,
            ),
          AttentionBlock(
            ch,
            use_checkpoint=use_checkpoint,
            num_heads=num_heads,
            num_head_channels=dim_head,
            use_new_attention_order=use_new_attention_order,
              ) if not use_spatial_transformer else
          SpatialTransformer(  # always uses a self-attn
                            ch, num_heads, dim_head, depth=transformer_depth, context_dim=context_dim,
                            disable_self_attn=disable_middle_self_attn, use_linear=use_linear_in_transformer,
                            use_checkpoint=use_checkpoint
                        ),
          ResBlock(
            ch,
            time_embed_dim,
            dropout,
            dims=dims,
            use_checkpoint=use_checkpoint,
            use_scale_shift_norm=use_scale_shift_norm,
        ),
      )
    #self.middle_block is one module composed of three layers in sequence
    #TimestepEmbedSequential is a container (like nn.Sequential), not a single “operation” ??
        self.feature_size += ch

        self.output_blocks = nn.ModuleList([])
        for level, mult in list(enumerate(channel_mult))[::-1]:
          for i in range(self.num_res_blocks[level] + 1):
              ich = input_block_chans.pop()
              layers = [
                  ResBlock(
                      ch + ich,
                      time_embed_dim,
                      dropout,
                      out_channels=model_channels * mult,
                      dims=dims,
                      use_checkpoint=use_checkpoint,
                      use_scale_shift_norm=use_scale_shift_norm,
                  )
              ]
              ch = model_channels * mult
              if ds in attention_resolutions:
                  if num_head_channels == -1:
                      dim_head = ch // num_heads
                  else:
                      num_heads = ch // num_head_channels
                      dim_head = num_head_channels
                  if legacy:
                      #num_heads = 1
                      dim_head = ch // num_heads if use_spatial_transformer else num_head_channels
                  if exists(disable_self_attentions):
                      disabled_sa = disable_self_attentions[level]
                  else:
                      disabled_sa = False
                  if not exists(num_attention_blocks) or i < num_attention_blocks[level]:
                      layers.append(
                          AttentionBlock(
                              ch,
                              use_checkpoint=use_checkpoint,
                              num_heads=num_heads_upsample,
                              num_head_channels=dim_head,
                              use_new_attention_order=use_new_attention_order,
                          ) if not use_spatial_transformer else SpatialTransformer(
                              ch, num_heads, dim_head, depth=transformer_depth, context_dim=context_dim,
                              disable_self_attn=disabled_sa, use_linear=use_linear_in_transformer,
                              use_checkpoint=use_checkpoint
                          )
                      )
              if level and i == self.num_res_blocks[level]:
                  out_ch = ch
                  layers.append(
                      ResBlock(
                          ch,
                          time_embed_dim,
                          dropout,
                          out_channels=out_ch,
                          dims=dims,
                          use_checkpoint=use_checkpoint,
                          use_scale_shift_norm=use_scale_shift_norm,
                          up=True,
                      )
                      if resblock_updown
                      else Upsample(ch, conv_resample, dims=dims, out_channels=out_ch)
                  )
                  ds //= 2
              self.output_blocks.append(TimestepEmbedSequential(*layers))
              self._feature_size += ch

        self.out = nn.Sequential(
          normalization(ch),
          nn.SiLU(),
          zero_module(conv_nd(dims, model_channels, out_channels, 3, padding=1)),
          )
        if self.predict_codebook_ids:
          self.id_predictor = nn.Sequential(
          normalization(ch),
          conv_nd(dims, model_channels, n_embed, 1),
          #nn.LogSoftmax(dim=1)  # change to cross_entropy and produce non-normalized logits
        )

        if load_from_ckpt is not None:
          self.load_from_ckpt(load_from_ckpt)

    def load_from_ckpt(self, ckpt_path):
      input_ch = self.state_dict()["input_blocks.0.0.weight"].shape[1]
      assert input_ch >= 4 and input_ch // 4 * 4 == input_ch, "Input channels must be at a multiplier 4 to load from SD ckpt"
      output_ch = self.state_dict()["out.2.weight"].shape[0]
      assert output_ch >= 4 and output_ch // 4 * 4 == output_ch, "Output channels must be at a multiplier 4 to load from SD ckpt"
      sd = th.load(ckpt_path)
      sd_ = {}
      for k,v in sd["state_dict"].items():
          if k.startswith("model.diffusion_model"):
              sd_[k.replace("model.diffusion_model.", "")] = v

      if input_ch > 4:
          # Scaling for input channels so that the gradients are not too large
          scale = input_ch // 4
          sd_["input_blocks.0.0.weight"] = sd_["input_blocks.0.0.weight"] / scale
          sd_["input_blocks.0.0.weight"] = sd_["input_blocks.0.0.weight"].repeat(1, scale, 1, 1)

      if output_ch > 4:
          # No scaling for output channels
          scale = output_ch // 4
          sd_["out.2.weight"] = sd_["out.2.weight"].repeat(scale, 1, 1, 1)
          sd_["out.2.bias"] = sd_["out.2.bias"].repeat(scale)

      missing, unexpected = self.load_state_dict(sd_, strict=False)

      if len(missing) > 0:
          print(f"Load model weights - missing keys: {len(missing)}")
          print(missing)
      if len(unexpected) > 0:
          print(f"Load model weights - unexpected keys: {len(unexpected)}")
          print(unexpected)
  #This function loads a Stable Diffusion checkpoint into your custom model,
  #while handling cases where the number of input/output channels is bigger
  #than in the checkpoint by repeating and scaling the weights so they fit

    def convert_to_fp16(self):
    #Convert the torso of model to floats
      self.input_blocks.apply(convert_module_to_f16)
      self.middle_block.apply(convert_module_to_f16)
      self.output_blocks.apply(convert_module_to_fp16)

    def convert_to_fp32(self):
      self.input_blocks.apply(convert_module_to_fp32)
      self.middle_block.apply(convert_module_to_fp32)
      self.output_blocks.apply(convert_module_to_fp32)


    def forward(self, x, t=None, context=None, context_ca=None, y=None, **kwargs):

       assert (y is not None) == (
            self.num_classes is not None
        ), "must specify y if and only if the model is class-conditional"
       hs = []
       t_emb = timestep_embedding(t, self.model_channels, repeat_only=False)
       emb = self.time_embed(t_emb)

       if self.num_classes is not None:
           assert y.shape[0] == x.shape[0]
           emb = emb + self.label_emb(y)

       h = x.type(self.dtype)
       if context is not None:
           h = th.cat([h, context], dim=1)
       for module in self.input_blocks:
           h = module(h, emb, context_ca)
           hs.append(h)
       h = self.middle_block(h, emb, context_ca)
       for module in self.output_blocks:
           h = th.cat([h, hs.pop()], dim=1)
           h = module(h, emb, context_ca)
       '''
        hs is a stack (list) of skip-connection feature maps saved during the encoder/down path.
        .pop() pulls the last saved feature map (LIFO), which matches the current spatial resolution of h. (As you upsample, you pair with the corresponding encoder feature at the same size.)
        th.cat([...], dim=1) concatenates along channel dimension (N, C, H, W).
        So channels become C = C_decoder + C_skip.
        Why cat? Classic UNet: you fuse decoder features with the aligned encoder features to recover detail.
        '''
       h = h.type(x.dtype)
       if self.predict_codebook_ids:
           return self.id_predictor(h)
       else:
           return self.out(h)
      
    def get_midblock_features(self, x, t=None, context=None, context_ca=None, y=None, **kwargs):
      """
      Apply the model to an input batch and return the features from the middle block.
      :param x: an [N x C x ...] Tensor of inputs.
      :param t: a 1-D batch of timesteps.
      :param context: conditioning plugged in via crossattn
      :param y: an [N] Tensor of labels, if class-conditional
      """
      assert (y is not None) == (
          self.num_classes is not None
      ), "must specify y if and only if the model is class-conditional"
      hs = []
      t_emb = timestep_embedding(t, self.model_channels, repeat_only=False)
      emb = self.time_embed(t_emb)

      if self.num_classes is not None:
          assert y.shape[0] == x.shape[0]
          emb = emb + self.label_emb(y)

      h = x.type(self.dtype)
      if context is not None:
          h = th.cat([h, context], dim=1)
      for module in self.input_blocks:
          h = module(h, emb, context_ca)
          hs.append(h)
      h = self.middle_block(h, emb, context_ca)
      return h
              
"""
Apply the model to an input batch.
:param x: an [N x C x ...] Tensor of inputs.
:param t: a 1-D batch of timesteps.
:param context: conditioning plugged in via crossattn
:param y: an [N] Tensor of labels, if class-conditional.
:return: an [N x C x ...] Tensor of outputs.
"""


if __name__ == "__main__": #Only run the following code if this file is executed directly, not when it’s imported as a module
    unet = UNetModel(
        image_size=32,
        in_channels=8,
        model_channels=320,
        out_channels=4,
        num_res_blocks=2,
        attention_resolutions=(4,2,1),
        dropout=0.0,
        channel_mult=(1, 2, 4, 4),
        num_heads=8,
        use_spatial_transformer=True,
        context_dim=768,
        transformer_depth=1,
        legacy=False,
        load_from_ckpt="/export/scratch/ra97ram/checkpoints/sd/v1-5-pruned.ckpt"
    )
    print(f"UNetModel has {sum(p.numel() for p in unet.parameters())} parameters")